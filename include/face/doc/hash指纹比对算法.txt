hash指纹比对算法

本算法旨在提高人脸特征比对的速度。算法缺点：会降低人脸比对的命中率。具体见测试结果。

算法概要：对每个特征生成hash指纹(32bit)。先计算新特征和库特征的海明距离如果海明距离小于阈值（一般取7~10）才进行常规的特征比对。因为计算海明距离用的查表算法。非常快。而且一般小于阈值的特征一般只占总特征个数的百分之一不到。因此算法非常快。

如何计算hash指纹：
基本思想就是把特征看成是一维图像。对图像进行缩放。

计算hash指纹细节：
把特征2165维特征分成 32个区间，每个区间大概包含[2165/32]个值。求每个区间之和得到32个数。与事先统计好的中位数比较。大于中位数返回1，否则返回0.再把这32个0或者1拼成32bit的整数。这个整数就是hash指纹。

// 测试结果:
// 不用hash     识别率 96.23%
// 海明距离<10  识别率 92.42% 性能提升50.32倍
// 海明距离<9   识别率 89.60% 性能提升116.24倍
// 海明距离<8   识别率 85.26% 性能提升298.20倍

其他：
32个区间的中位数:
      int mid[32]=  {355, 297, 409, 463, 455, 415, 622, 350,
        508, 336, 590, 339, 361, 1080, 1051, 1218,
        673, 1115, 883, 425, 640, 2975, 2382, 2263,
        1830, 2657, 2594, 3456, 2643, 4613, 5008, 2413,
      }; // 中位数

算法源码: 
uint gethash(FEAT_T* feat, uint m) {
  uint cnt[32] = {0}, h=0, j;
  for (j=0; j<m; ++j) {
    int k = j*32/m;
    cnt[k] += feat[j];
  }
  for (j=0; j<32; ++j) {
    h = (h<<1)|(mid[j]>cnt[j]);
  }
  return h;
}
